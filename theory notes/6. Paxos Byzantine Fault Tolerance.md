```mermaid
flowchart TD
  init([Init])-->|Send pre-prep|pp(Pre-prep'd)
  pp-->|Send prep|wpp(Wait for 2f+1)
  wpp-->|at least 2f+1|p(Prepared)
  p-->|Send commit|wp(Wait for 2f+1)
  wp-->|at least 2f+1|c(Committed)
  c-->wait(Wait for all earlier reqs to exec)
  wait-->exec(Execute seq)
  exec-->fin([Complete])
  wpp-->|timeout|vc([View Change])
  wp-->|timeout|vc
  wait-->|timeout|vc
  vc-->|restart|init
```
## Objective
- Ensure safety and liveness despite network asynchrony
	- Establish a total order of execution of requests coming from clients (pre-prepare and prepare)
	- Ensure requests are observed consistently across views (commit)
		- View is a configuration of replica with primary (view#  mod N)
- Other replicas monitor the primary and perform a view change if the primary fails

PBFT uses 3f +1 nodes - why?
- at most f nodes can fail. leaving 2f + 1. but there must still be liveness aka good things must happen/progress. so u still need at least f + 1 acceptors to progress.
- some Clients, Primary and several replicas.
- 3 stages
	- pre-prepare
		- Acknowledge a unique sequence number for the request (from client)
	- prepare
		- The replicas to agree on a unique sequence number for the request (from client)
	- commit
		- Establish total order in all replicas

### PBFT state of replica
- A replica ID “i” (between 0 and N-1)
- A view number v#, initially 0
- A primary replica
	- ID of primary replica: v# mod N

- A log of <op, seq#, status> entries
	- op: the operation/request
	- seq#: a sequence number identifying the operation
	- Status: pre-prepared, prepared or committed 
### Pre-prepare stage
Goal:
- Acknowledge a unique sequence number for the request (from client)
Send process:
- Client request from primary. 
- Primary assign sequence number and sends <pre-prepare, v#, seq#, op>
- Record operations in the log
- Malicious primary can send different seq# for the same op
- or use a duplicate seq#
Receive process:
- check v# and seq# valid.
	- no dupes or skips
- accept or drop

### Prepare Stage
Goal:
- The replicas to agree on a unique sequence number for the request (from client)

Send:
- Replicas send prepare message to all other replicas including primary
- <prepare, i#, v#, seq#, op>

Receive:
- check v# and seq# again 
- from each replica pov, can only proceed to next stage aka mark as prepared when 2f+1 (including self vote) distinct, valid and matching prepare messages are received.
- record in log as prepared
Guarantee: 2 diff requests (from client) will never have same seq#, since 
- non faulty replicas agree on seq# in prepare stage
- non faulty replicas agree on total order for requests within a view v# (same view)
- doesnt guarantee clients will observe the same total order.
- we need the final commit stage.
### Commit stage
Goal:
- Establish total order in all replicas. so all replicas can execute operations in the same order
Send:
- Send commit messages to all 
- Each commit message contains <i, v#, seq#, op> for replica “i”
- Each replica send the commit to all other replicas

Receive:
- Check the validity of v# and seq# as pre-prepare and prepare stage

Guarantee: 
- Valid <pre-prepare> for “op” is received
- <prepare> was recorded in the log
- 2f+1 (including self-vote) distinct, valid and matching <commit> messages (i.e. with the same seq# and v#) received
	- Thus continues with at most “f” byzantine failures
	- The operation is recorded in the log as <committed>
- Commit stage guarantees a consensus among the non-malicious replicas regarding the value for the agreed seq# in the prepare stage

### Execute stage
A replica executes request op iff
- committed stage succeeds (check log)
- all requests with lower seq# are already executed
- reply primary
- Primary replies client if receive f+1 executed